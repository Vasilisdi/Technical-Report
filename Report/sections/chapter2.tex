\chapter{Theoretical Background}
\label{chap2}
\section{Fundamentals of Bearing Fault Frequencies}
{
\subsection{Overview}
{
The most significant challenge that the authors had to deal with is that of the faulty cases detection. For this reason, fault and unfault models have been developed, and series of comparisons between the actual model generated by apparatus measurements and these two situational models are being executed. This development constitutes a real challenge since this is the main criterion that identifies the state of the motor.
}

\subsection{Unfault and Fault Models}
{
As previously mentioned, the authors make use of a model-based approach, which entails that the main concept is comparison-oriented. Specifically, there is the unfault model, which contains a high-amplitude peak at the shaft rotating frequency $F_{\omega}$. In addition to that, it can be noticed in Figure~\ref{fig:faultsunfaults} that some other patterns distinct themselves from the previously-mentioned unfault model. Regarding the unbalance model, it is obvious that the amplitude at the first tone is much greater. In the case of the misalignment model, it can be noticed that the tone at $2F_{\omega}$ has a much greater amplitude while the amplitude at the tone of the shaft speed $F_{\omega}$ remains at a high level. In the case of looseness, there are some more tones prevailing on the spectrum, among the tones related to the shaft speed. To top it all off, the most important vibration spectrum is that of the bearing failure (Refer to Figure~\ref{fig:faultTree}). Every bearing is characterized by four critical frequencies, given by its manufacturer, and these frequencies are associated with the four bearing components (inner and outer ring, balls, and cage):

\begin{itemize}
	\item BPFO (Ball Pass Frequency Outer) - outer race failure
	\item BPFI (Ball Pass Frequency Inner) - inner race failure
	\item BSF (Ball Spin Frequency) - rolling element failure
	\item FTF (Fundamental Train Frequency) - cage failure
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{figures/FaultsAndUnfaults.png}
\caption{Fault and unfault spectrum graphs \cite{Betta2002}.}
\label{fig:faultsunfaults}
\end{figure}

The procedure to calculate critical frequencies involves two steps: first computing the bearing frequency factors, then deriving the vibration frequencies. The following analysis covers the case where the inner race rotates while the outer race remains stationary.

\begin{align}
	F_{\text{OR}} &= \frac{Z}{2} \left(1 - \frac{d}{D} \cos\alpha\right) 
	&&\text{(Outer Race Fault)} \label{eq:OR} \\
	F_{\text{IR}} &= \frac{Z}{2} \left(1 + \frac{d}{D} \cos\alpha\right) 
	&&\text{(Inner Race Fault)} \label{eq:IR} \\
	F_{\text{FTF}} &= \frac{1}{2} \left(1 - \frac{d}{D} \cos\alpha\right) 
	&&\text{(Cage Frequency, Inner Race Rotating)} \label{eq:FT} \\
	F_{\text{BS}} &= \frac{D}{d} \left[1 - \left(\frac{d}{D}\right)^2 \cos^2\alpha\right] 
	&&\text{(Ball Spin Frequency)} \label{eq:BS}
\end{align}

Then, the aforementioned factors when multiplied with shaft speed ($f$) give specific critical bearing vibration frequencies:
\begin{align}
	\text{BPFO} &= f \times F_{\text{OR}} \label{eq:BPFO} \\
	\text{BPFI} &= f \times F_{\text{IR}} \label{eq:BPFI} \\
	\text{BSF}  &= f \times F_{\text{BS}} \label{eq:BSF} \\
	\text{FTF}  &= f \times F_{\text{FTF}} \label{eq:FTF}
\end{align}

where:
\begin{align*}
	&f    &&: \text{Shaft rotational speed (\si{\hertz})} \\
	&\text{BPFI} &&: \text{Ball pass frequency, inner race} \\
	&\text{BPFO} &&: \text{Ball pass frequency, outer race} \\
	&\text{FTF}  &&: \text{Fundamental train frequency} \\
	&\text{BSF}  &&: \text{Ball spin frequency} \\
	&Z    &&: \text{Number of rolling elements} \\
	&D    &&: \text{Pitch circle diameter of the bearing (\si{\milli\meter})} \\
	&d    &&: \text{Rolling element (ball) diameter (\si{\milli\meter})} \\
	&\alpha &&: \text{Contact angle (\si{\degree})} \\
\end{align*}

It is also worth noting that the bearing frequency factors can be obtained through: 
\begin{itemize}
	\item Manufacturer-provided values
	\item Direct calculation using the above equations \eqref{eq:OR}--\eqref{eq:BS}
	\item Reverse calculation from measured vibration frequencies \eqref{eq:BPFO}--\eqref{eq:FTF}
\end{itemize}

To summarize the preceding analysis, Figure \ref{fig:faultTree} provides a clear visualization of the fault diagnosis procedure. When analysis reveals elevated frequency tones, a systematic approach must be followed to identify the source of these dominant frequencies. This process essentially involves mapping characteristic vibration patterns to specific machine faults on a frequency spectrum plot.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[node distance=1.5cm]
		\node (box1) [draw, rectangle] at (0,0) {Unfault model};
		\node (box2) [draw, rectangle, left of=box1, node distance=6cm] {Fault model};
		\node (box3) [draw, rectangle] at (-7.5,-2) {Unbalance};
		\node (box4) [draw, rectangle] at (-2,-2) {Misalignment};
		\node (box5) [draw, rectangle] at (-5,-2) {Bearing failure};
		\node (box6) [draw, rectangle] at (-10,-2) {Looseness};
		\node (box7) [draw, rectangle] at (-6,-4) {BPFO};
		\node (box8) [draw, rectangle] at (-2,-4) {BPFI};
		\node (box9) [draw, rectangle] at (-4,-4) {BSF};
		\node (box10) [draw, rectangle] at (-8,-4) {FTF};
		
		% Arrows with labels
		\draw[->] (box2) -- node[midway, above] {No} (box1);
		\draw[->] (box2) -- (box3);
		\draw[->] (box2) -- (box4);
		\draw[->] (box2) -- (box5);
		\draw[->] (box2) -- (box6);
		\draw[->] (box5) -- (box7);
		\draw[->] (box5) -- (box8);
		\draw[->] (box5) -- (box9);
		\draw[->] (box5) -- (box10);
	\end{tikzpicture}
	\caption{Fault tree analysis diagram showing the relationship between machine conditions and specific fault frequencies.} \label{fig:faultTree}
\end{figure}

It must be that a fault-emulation method can be used in such cases to simulate the faulty models. This entails that additional tones can be stressed, and crucial spectra modifications may take place for research and comparison purposes.
}


}




\section{Algorithms and Technologies}
% Summary of FFT, data flow, etc.
\subsection{Signal Processing}
\subsubsection{Fast Fourier Transform (FFT)}
{
The Fast Fourier Transform (FFT) is an efficient algorithm for computing the Discrete Fourier Transform (DFT) and its inverse. One of the most prominent FFT algorithms, the Cooley-Tukey algorithm \cite{CooleyTukey1965}, employs a divide-and-conquer approach to reduce the computational complexity from $\mathcal{O}(n^2)$ (for the naive DFT) to $\mathcal{O}(n \log n)$, enabling significant speedups for large amount of data. The mathematical formulation, given a waveform $x_0, x_1, \dots, x_{n-1}$, containing real values, is structured as follows:
\begin{equation}
	X(j) = \sum_{k=0}^{n-1} x(k) \exp\left( - \frac{i2\pi jk}{n} \right) \quad, \text{for} \quad j = 0,1,\dots,n-1
	\label{eq:DFT}
\end{equation}

This reduces complexity from $\mathcal{O}(n^2)$ (naive DFT entails direct implementation of the equation \eqref{eq:DFT}) to $\mathcal{O}(n \log n)$ (a Fast Fourier Transform implementation), enabling major time savings for complex and large-scale transforms. It is also worth articulating that the complexity can be interpreted as the number of operations executed \cite{CooleyTukey1965}, \cite{Singeleton1967}. 

Both algorithms are implemented in major numerical packages including MATLAB and NumPy's routines \cite{FFT}. What is highlighted  by Singeleton is that the Cooley-Tukey approach is considerably faster and decently performing especially when coupled with some additional practices so as to execute the Fast Fourier Transform \cite{Singeleton1967}. 

The computation time according to the aforementioned article decreases drastically by making use of the Cooley-Tukey algorithm. In addition, this very algorithm performs and adapts better to different applications compared to Good's, Danielson's and Goertzel's approaches.

Cooley and Tukey proved that the sample length can be composite size where it is preferable to make use of sample points sized as power of 2, especially when it comes to personal computers with binary arithmetic system. In addition to this the authors have proven that the power of 3 is formally the most efficient approach, however in the context of the fast Fourier Analysis the so-called Radix-2 implementation is the prominent one \cite{CooleyTukey1965}.

\begin{equation}
	N = 2^m \label{eq:radix_condition}
\end{equation} 

It is hereby worth it elaboration on the Fast Fourier Transform algorithm \cite{CooleyTukey1965}. The indices of the equation \eqref{eq:DFT} for the Radix-2 scenario can be expressed as follows: 

\begin{equation}
	\begin{aligned}
		j &= j_{m-1} \cdot 2^{m-1} + j_{m-2} \cdot 2^{m-2} + \dots + j_1 \cdot 2 + j_0, \\
		k &= k_{m-1} \cdot 2^{m-1} + \dots + k_1 \cdot 2 + k_0,
	\end{aligned}
\end{equation}

where \( j_{v} \) and \( k_{v} \) are the contents of the respective bit positions within the binary representation, which ensues that they are equal to 0 or 1.

The aforementioned set-up (see eq. \eqref{eq:DFT}) leads to the following equation \eqref{eq:FFT}, encompassing twiddle factors expressed as:

\begin{equation}
	W = e^{-2\pi i/N}
\end{equation}

And the Fast Fourier Transform:

\begin{equation}
	X(j_{m-1}, \cdots ,j_0) = \sum_{k_{0}} \sum_{k_{1}} \cdots \sum_{m-1} x({k_{m-1} , \cdots , k_0}) \cdot W^{j \cdot k_{m-1} \cdot 2^{m-1} + \cdots + j \cdot k_0}
	\label{eq:FFT}
\end{equation}

where as per the first step:
\begin{equation}
	W^{j \cdot k_{m-1} \cdot 2^{m-1}} = W^{j_{0} \cdot k_{m-1} \cdot 2^{m-1}}
\end{equation}

Furthermore, in the context of the first calculation, the first array can be expressed as follows:

\begin{equation}
	x_{1}(j_0, k_{m-2}, \cdots, k_0) = \sum_{\mathbf{k_{m-1}}} x(\mathbf{k_{m-1, \cdots, k_0}}) \cdot W^{\mathbf{j_0}  \cdot \mathbf{k_{m-1}} \cdot \mathbf{2^{m-1}} }
\end{equation}

And hereunder can be contemplated that proceeding to the next innermost-successive sum:

\begin{equation}
	W^{j \cdot k_{m-1} \cdot 2^{m-1}} = W^{(j_{l-1} \cdot 2^{l-1} + \cdots + j_0) \cdot k_{m-l} \cdot 2^{m-l}}
\end{equation}

followed by the calculation of the arrays:

\begin{equation}
	x_{l}(j_0, \cdots, j_{l-1} , k_{m-l-1} , \cdots, k_0) = \sum_{\mathbf{k_{m-l}}} x_{l-1}(j_0, \cdots , j_{l-2} \cdots, k_{m-l} , \cdots , k_0) \cdot  W^{(j_{l-1} \cdot 2^{l-1} + \cdots + j_0) \cdot k_{m-l} \cdot 2^{m-l}}
\end{equation}

for l = 1, 2, ... , m

And this could constitute a recursive procedure obtaining the successive arrays. And last but not least, this finally could lead to the calculation of X spectrum.

All in all, this section yields an overview of utmost importance highlighting the most invaluable Fourier Transform algorithms expressed by equation \eqref{eq:DFT} and equation \eqref{eq:FFT}.
}

\subsection{Embedded Systems \& IoT}
\subsubsection{ADXL335 Sensor}
Analog signal from sensor breakout to arduino. To elaborate on signal transferring
\begin{itemize}
\item what a sensor breakout is
\item what analog signal is
\end{itemize}


\subsubsection{Arduino Microcontroller}
UART serial communication sending data to RPi. To elaborate on this protocol
\begin{itemize}
\item what serial protocol is
\item what Arduino is
\end{itemize}

\subsubsection{Raspberry Pi 4}
RPi receiving data using a script and posing HTTP Post data to a supabase api. Elaborate on this

\begin{itemize}
\item how to collect data and analyse
\item what Raspberry Pi 4 is
\end{itemize}




\subsection{Backend \& Database}
\subsubsection{Supabase}
\begin{itemize}  
	\item PostgreSQL. 
	\item APIs
	\item what http post is
\end{itemize}  

\subsubsection{Vercel and Next.js}
\begin{itemize}  
	\item nextjs 
	\item vercel
\end{itemize} 